import asyncio
import functools
import logging
import uuid
from abc import ABC
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, ClassVar, Dict, List, Literal, Optional, Type

from rift.agents.agenttask import AgentTask
from rift.llm.openai_types import Message as ChatMessage
from rift.lsp import LspServer as BaseLspServer
from rift.lsp import rpc_method

logger = logging.getLogger(__name__)


class Status(Enum):
    running = "running"
    done = "done"
    error = "error"
    accepted = "accepted"
    rejected = "rejected"


@dataclass
class RequestInputRequest:
    msg: str
    place_holder: str = ""


@dataclass
class RequestInputResponse:
    response: str


@dataclass
class RequestChatRequest:
    messages: List[ChatMessage]


@dataclass
class RequestChatResponse:
    message: ChatMessage  # TODO make this richer


AgentTaskId = str


@dataclass
class AgentRunParams(ABC):
    agent_id: str


@dataclass
class RunAgentParams:
    agent_type: str
    agent_params: Any
    agent_id: Optional[str]


@dataclass
class AgentProgress:
    agent_type: Optional[str] = None
    agent_id: Optional[str] = None
    tasks: Optional[Dict[str, Any]] = None
    payload: Optional[Any] = None


@dataclass
class AgentRunResult(ABC):
    ...


@dataclass
class AgentState(ABC):
    ...


@dataclass
class Agent:
    """
    Agent base class.

    `agent_type` is defined in the source code.
    `agent_id` a unique identifier generated by convention in the lsp's handler for 'morph/run'
    `state` is a namespace encapsulating all special state for the agent
    `tasks` is a list of `AgentTask`s and is used to report progress
    `server` is a handle to the global language server
    """

    agent_type: ClassVar[str]
    server: Optional[BaseLspServer] = None
    state: Optional[AgentState] = None
    agent_id: Optional[str] = None
    tasks: List[AgentTask] = field(default_factory=list)
    task: Optional[AgentTask] = None

    def get_display(self):
        return self.agent_type, self.description

    def __str__(self):
        return f"<{self.agent_type}> {self.agent_id}"

    @classmethod
    def create(cls, params: RunAgentParams, *args, **kwargs):
        """
        Factory function which is responsible for constructing the agent's state.
        """
        ...

    async def main(self):
        """
        Called by the LSP server to handle `morph/run`.
        """
        self.task = AgentTask(description=self.agent_type, task=asyncio.create_task(self.run()))

        return await self.task.run()

    async def run(self) -> AgentRunResult:
        ...

    def add_task(self, task: AgentTask):
        """
        Register a subtask.
        """
        self.tasks.append(task)
        return task

    async def cancel(self, msg: Optional[str] = None):
        """
        Cancel all tasks and update progress. Assumes that `Agent.main()` has been called and that the main task has been created.
        """
        logger.info(f"{self.agent_type} {self.agent_id} cancel run {msg or ''}")
        self.task.cancel()
        for task in self.tasks:
            if task is not None:
                task.cancel()

        await self.send_progress()

    async def request_input(self, req: RequestInputRequest) -> str:
        """
        Prompt the user for more information.
        """
        try:
            response = await self.server.request(
                f"morph/{self.agent_type}_{self.agent_id}_request_input", req
            )
            return response["response"]
        except Exception as e:
            logger.info(f"Caught exception in `request_input`, cancelling Agent.run(): {e}")
            await self.cancel()
            raise asyncio.CancelledError

    async def send_update(self, msg: str):
        """
        Creates a notification toast in the Rift extension by default.
        """
        await self.server.notify(
            f"morph/{self.agent_type}_{self.agent_id}_send_update",
            {"msg": f"[{self.agent_type}] {msg}"},
        )

    async def request_chat(self, req: RequestChatRequest) -> asyncio.Future[RequestChatResponse]:
        return await self.server.request(
            f"morph/{self.agent_type}_{self.agent_id}_request_chat", req
        )

    async def send_progress(self, payload: Optional[Any] = None, payload_only: bool = False):
        """
        Each agent is responsible for periodically notifying the client at `morph/{agent_type}_{agent_id}_send_progress` about the status of its outstanding tasks.

        Assumes that `Agent.main()` has been run and the main task has been created.
        """
        if payload_only:
            tasks = None
        else:
            try:
                """
                In the Rift Agents webview view, this corresponds precisely to a single log item corresponding to this agent.
                """
                tasks = {
                    "task": {"description": AGENT_REGISTRY[self.task.description].display_name, "status": self.task.status},
                    "subtasks": (
                        [{"description": x.description, "status": x.status} for x in self.tasks]
                    ),
                }
            except Exception as e:
                logger.debug(f"Caught exception: {e}")
                tasks = None

        progress = AgentProgress(
            agent_type=self.agent_type,
            agent_id=self.agent_id,
            tasks=tasks,
            payload=payload,
        )

        await self.server.notify(f"morph/{self.agent_type}_{self.agent_id}_send_progress", progress)

    async def send_result(self) -> ...:
        ...


@dataclass
class AgentRegistryItem:
    """
    Stored in the registry by the @agent decorator, created upon Rift initialization.
    """

    agent: Type[Agent]
    agent_description: str
    display_name: Optional[str] = None

    def __post_init__(self):
        if self.display_name is None:
            self.display_name = self.agent_type    


@dataclass
class AgentRegistryResult:
    """
    To be returned as part of a list of available agent workflows to the language server client.
    """

    agent_type: str
    agent_description: str
    display_name: Optional[str] = None
    agent_icon: Optional[str] = None  # svg icon information


@dataclass
class AgentRegistry:
    """
    Track all agents in one place.
    """
    registry: Dict[str, Type[Agent]] = field(default_factory=dict)

    def __getitem__(self, key):
        return self.get_agent(key)

    def register_agent(
        self, agent: Type[Agent], agent_description: str, display_name: Optional[str] = None
    ) -> None:
        if agent.agent_type in self.registry:
            raise ValueError(f"Agent '{agent.agent_type}' is already registered.")
        self.registry[agent.agent_type] = AgentRegistryItem(
            agent=agent, agent_description=agent_description, display_name=display_name,
        )

    def get_agent(self, agent_type: str) -> Type[Agent]:
        result = self.registry.get(agent_type)
        if result is not None:
            return result.agent
        else:
            raise ValueError(f"Agent not found: {agent_type}")
        return result.agent

    def get_agent_icon(self, item: AgentRegistryItem) -> ...:
        return None  # TODO

    def list_agents(self) -> List[AgentRegistryResult]:
        return [
            AgentRegistryResult(
                agent_type=item.agent.agent_type,
                agent_description=item.agent_description,
                agent_icon=self.get_agent_icon(item),
                display_name=item.display_name
            )
            for item in self.registry.values()
        ]


AGENT_REGISTRY = AgentRegistry()


def agent(agent_description: str, display_name: Optional[str] = None):
    def decorator(cls: Type[Agent]) -> Type[Agent]:
        # @functools.wraps(cls)  # Ensure the original class information is preserved
        # class DecoratedAgent(cls):
        #     pass
        AGENT_REGISTRY.register_agent(cls, agent_description, display_name)
        return cls

    return decorator
